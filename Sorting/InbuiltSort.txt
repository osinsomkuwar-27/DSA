
Java Inbuilt Sort (Using Arrays.sort and Collections.sort)

Java provides inbuilt methods to sort arrays and collections efficiently using optimized algorithms.

1. Arrays.sort() — for arrays
--------------------------------
- Used to sort primitive and object arrays.
- Internally uses:
  - Dual-Pivot Quicksort for primitives → Time: O(n log n)
  - TimSort for objects (stable sort)   → Time: O(n log n)

Example:
int[] arr = {5, 2, 8, 3};
Arrays.sort(arr);  // sorts in ascending order

int[] arr = {5, 2, 8, 3};
Arrays.sort(arr, 0, 2); // sorts elements at index 0 to 2 in ascending order so the output will be (2,5,8,3)

2. Collections.sort() — for ArrayList or List
---------------------------------------------
- Used to sort Lists of objects.
- Internally uses TimSort, a hybrid of Merge Sort and Insertion Sort.
- Maintains stability (relative order of equal elements).

Example:
List<Integer> list = new ArrayList<>(Arrays.asList(4, 1, 7, 3));
Collections.sort(list);  // ascending order

3. Sorting in Descending Order
------------------------------
Use custom comparator (lambda or anonymous class).

Example:
Collections.sort(list, (a, b) -> b - a);  // descending

Arrays.sort(arr, Collections.reverseOrder()); // for object arrays only (not primitives)

Time Complexity:
----------------
- Best Case:    O(n log n)
- Average Case: O(n log n)
- Worst Case:   O(n log n)

Space Complexity:
-----------------
- O(n) → for TimSort (uses temporary arrays)

Advantages:
-----------
✔ Highly optimized and production-ready  
✔ Short and clean code  
✔ Stable sort (for objects and lists)

Note:
-----
- Arrays.sort() on primitive types is **not stable**.
- Collections.sort() and Arrays.sort(Object[]) are **stable**.
